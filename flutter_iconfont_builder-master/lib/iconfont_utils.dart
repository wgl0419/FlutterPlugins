import 'dart:io';
import 'dart:math';

import 'package:flutter_iconfont_builder/font_config.dart';
import 'package:flutter_iconfont_builder/font_demo_template.dart';
import 'package:recase/recase.dart';
import 'package:yaml/yaml.dart';
import 'package:yaml_edit/yaml_edit.dart';

import 'font_model.dart';

class IconFontUtils {
  static List<FontModel> models = [];
  static List<String> cssNames = [];
  static String buildIconToHtmlCode(List<FontModel> fonts, List<String> cssNames, String className) {
    String _className = ReCase(className).pascalCase;
    StringBuffer htmlSB = StringBuffer();
    String itemTemp = '''
  <li class="dib">
    <span class="icon {fontFamily}">{value}</span>
    <div class="code-name">{name}</div>
  </li>
  ''';

// path.basenameWithoutExtension(cssUrl)
    for (final font in fonts) {
      String _name = font.name.replaceAll('-', '_');
      _name = _name.startsWith('icon_') ? _name : 'icon_$_name';
      htmlSB.write(itemTemp
          .replaceFirst('{name}', _name)
          .replaceFirst('{value}', '&#xe${font.value}')
          .replaceFirst('{fontFamily}', font.familyName));
      htmlSB.writeln();
    }

    StringBuffer cssAndJsSB = StringBuffer('');
    for (final cssName in cssNames) {
      cssAndJsSB.write('<link rel="stylesheet" href="https://at.alicdn.com/t/${cssName}.css">');
      cssAndJsSB.writeln();
      cssAndJsSB.write('<script src="https://at.alicdn.com/t/${cssName}.js"></script>');
      cssAndJsSB.writeln();
    }
    return fontDemoTemplate
        .replaceAll(r'${iconFonts}', htmlSB.toString())
        .replaceAll(r'${fontCssAndJs}', cssAndJsSB.toString())
        .replaceAll(r'${className}', _className);
  }

  static String buildIconToDartCode(List<FontModel> fonts, String className) {
    String _className = ReCase(className).pascalCase;
    StringBuffer sb = StringBuffer();
    sb.write('''
/// This file is automatically generated. DO NOT EDIT, all your changes would be lost.
/// Generate Tools By flutter_iconfont_builder
/// File generation timeï¼š${DateTime.now()}

// ignore_for_file: constant_identifier_names

import 'package:flutter/widgets.dart';

class ${_className} {
  ${_className}._();
''');
    fonts.map((e) => e.familyName).toSet().forEach((_familyName) {
      sb.write('\ \ static const String _${_familyName} = \'${_familyName}\';\n');
    });
    sb.writeln();

    final List<String> _names = [];

    for (final font in fonts) {
      String _name = font.name.replaceAll('-', '_');
      _name = _name.startsWith('icon_') ? _name : 'icon_$_name';
      String _newName = _checkIconNames(_names, _name);
      if (_name != _newName) {
        FontModel f = FontModel(familyName: font.familyName, name: _newName, value: font.value);
        models[models.indexOf(font)] = f;
      }
      _names.add(_newName);
      sb.write('\ \ static const IconData $_newName = IconData(0xe${font.value}, fontFamily: _${font.familyName});\n');
    }
    sb.write('}');
    sb.writeln();
    return sb.toString();
  }

  static _checkIconNames(List<String> names, String name) {
    if (names.contains(name)) {
      return _checkIconNames(names, '${name}${Random().nextInt(1000)}');
    }
    return name;
  }

  static List<String?> getIconNames(String content) {
    RegExp iconNamesReg = RegExp(r'(?<=\.).+(?=:before)');
    List<String?> iconNames = iconNamesReg.allMatches(content).map((match) => match.group(0)).toList();
    return iconNames;
  }

  static List<String?> getIconValues(String content) {
    RegExp iconValuesReg = RegExp(r'(?<="\\e)[0-9a-zA-Z]{3}(?=";)');
    List<String?> iconValues = iconValuesReg.allMatches(content).map((match) => match.group(0)).toList();
    return iconValues;
  }

  static String? getProjectId(String content) {
    RegExp projectId = RegExp(r'Project id (\d+)');
    return projectId.firstMatch(content)?.group(1);
  }

  static String? getFontFamily(String content) {
    RegExp fontFamily = RegExp(r'font-family: "(.*)"');
    return fontFamily.firstMatch(content)?.group(1);
  }

  static String getFontDownloadUrl(String content) {
    RegExp ttfUrlReg = new RegExp(r'(?:(?:https?|ftp):\/\/)?[\w/\-?=%.]+\.ttf?[\w/\-?=%.]+');
    Iterable<RegExpMatch> matches = ttfUrlReg.allMatches(content);
    String ttfUrl = content.substring(matches.first.start, matches.first.end);
    ttfUrl = ttfUrl.startsWith('//') ? 'https:$ttfUrl' : ttfUrl;
    return ttfUrl;
  }

  static bool writeToFile(String content, String path) {
    File(path).writeAsStringSync(content, flush: true);
    return true;
  }

  static bool writeFontConfigToYaml(fontFamily, List<String> fontPaths) {
    final List? flutterFontConfig = fontConfig.flutterFont;
    YamlMap? iconFontMap = flutterFontConfig?.firstWhere((font) => font['family'] == fontFamily, orElse: () => null);

    final y = YamlEditor(fontConfig.pubSpecString);
    if (iconFontMap == null) {
      bool hasHolder = false;
      if (y.parseAt(['flutter', 'fonts'], orElse: () => YamlScalar.wrap(null)).value == null) {
        y.update(['flutter', 'fonts'], ['fonts space']);
        hasHolder = true;
      }

      y.appendToList([
        'flutter',
        'fonts'
      ], {
        'family': fontFamily,
        'fonts': fontPaths.map((f) => {'asset': f}).toList()
      });

      if (hasHolder) {
        y.remove(['flutter', 'fonts', 0]);
      }
    } else {
      final Set<String> fontsAsset = Set();
      fontsAsset.addAll(fontPaths.map((f) => f).toList());
      for (YamlMap asset in iconFontMap['fonts']) {
        final assetPath = asset.toMap()['asset'];
        if (assetPath != null) {
          fontsAsset.add(assetPath);
        }
      }

      y.update(['flutter', 'fonts', flutterFontConfig!.indexOf(iconFontMap), 'fonts'],
          fontsAsset.map((e) => {'asset': e}).toList());
    }
    return fontConfig.updatePubspec(y.toString());
  }
}

extension YamlMapConverter on YamlMap {
  dynamic _convertNode(dynamic v) {
    if (v is YamlMap) {
      return (v).toMap();
    } else if (v is YamlList) {
      var list = <dynamic>[];
      v.forEach((e) {
        list.add(_convertNode(e));
      });
      return list;
    } else {
      return v;
    }
  }

  Map<String, dynamic> toMap() {
    var map = <String, dynamic>{};
    this.nodes.forEach((k, v) {
      map[(k as YamlScalar).value.toString()] = _convertNode(v.value);
    });
    return map;
  }
}
